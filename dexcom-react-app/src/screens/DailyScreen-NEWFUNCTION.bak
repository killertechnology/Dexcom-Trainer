import React, { useState, useEffect } from "react";
import { Card, CardContent } from "../components/ui/card";
import { Button } from "../components/ui/button";
import { Bar, Line } from "react-chartjs-2";
import Scoreboard from "./Scoreboard"; // Adjust the path if needed
import Chart from 'chart.js/auto';

import {
  Chart as ChartJS,
  CategoryScale,
  BarController,
  LinearScale,
  PointElement,
  LineElement,
  BarElement,
  Title,
  Tooltip,
  Legend,
  Filler,
} from "chart.js";
import annotationPlugin from "chartjs-plugin-annotation";

ChartJS.register(
  BarController,
  CategoryScale,
  LinearScale,
  PointElement,
  LineElement,
  BarElement,
  Title,
  Tooltip,
  Legend,
  Filler,
  annotationPlugin
);

const DailyScreen = () => {
  const [majorEventsList,setMajorEvents] = useState([]);
  //let majorEventsList = [];
  const [selectedDate, setSelectedDate] = useState('2025-01-20');
  const [cgmData, setCgmData] = useState(new Array(96).fill(null));
  const [bolusData, setBolusData] = useState(new Array(96).fill(null));
  const [bolusDetails, setBolusDetails] = useState([]);
  const [scoreData, setScoreData] = useState({
    totalPoints: 55,
    pointsEarnedToday: 0,
    pointsDeductedToday: 0,
    negativeEvents: [],
    positiveEvents: 0,
  });

  const [spikeAnnotations, setSpikeAnnotations] = useState([]);
  const [dailyScore, setDailyScore] = useState(null);

  useEffect(() => {
    fetchData(selectedDate);
  }, [selectedDate]);

useEffect(() => {
  fetchDailyScores(selectedDate).then((data) => {
    if (data) {
      setDailyScore(data);
    }
  });
}, [selectedDate]);

let dataRequested = false;

  const fetchData = (date) => {
 
    console.log("fetching data");
    
    
    if (!dataRequested){
      dataRequested=true;
      Promise.all([
        fetch(`https://3tansqzb2f.execute-api.us-east-1.amazonaws.com/default/api/cgm?date=${date}`).then((res) => res.json()),
        fetch(`https://3tansqzb2f.execute-api.us-east-1.amazonaws.com/default/api/bolus?date=${date}`).then((res) => res.json())
    ])
    .then(([cgmResponse, bolusResponse]) => {
        
        // ‚úÖ Process CGM Data
        const formattedCgmData = new Array(96).fill(null);
        cgmResponse.forEach(entry => {
            const timestamp = new Date(Date.parse(entry["Timestamp"]));
            const index = timestamp.getHours() * 4 + Math.floor(timestamp.getMinutes() / 15);
            if (index >= 0 && index < 96) {
                formattedCgmData[index] = entry["CGM Value"];
            }
        });

        // ‚úÖ Process Bolus Data
        const formattedBolusData = new Array(96).fill(null);
        bolusResponse.forEach(entry => {
            const timestamp = new Date(Date.parse(entry["Timestamp"]));
            const index = timestamp.getHours() * 4 + Math.floor(timestamp.getMinutes() / 15);
            if (index >= 0 && index < 96) {
                formattedBolusData[index] = entry;
            }
        });

        // ‚úÖ Now BOTH datasets are available before calling detectBgSpikes()
        setCgmData([...formattedCgmData]);
        setBolusData([...formattedBolusData]);
        detectBgSpikes(formattedCgmData);
        detectCorrectionBolus(formattedCgmData, formattedBolusData, spikeTimes);
        detectEarlyBolus(formattedCgmData, formattedBolusData, spikeTimes);
        
        detectExpectedBolus(formattedCgmData, formattedBolusData);
        //detectSupplementalBolus(formattedBolusData);
        setMajorEvents(majorEventsList);
        
        
    })
    .catch(error => console.error("Error fetching data:", error));

    }
    
};

const fetchDailyScores = async (date) => {
  try {
    const response = await fetch(`https://3tansqzb2f.execute-api.us-east-1.amazonaws.com/default/api/scores/1?date=${date}`);
    if (!response.ok) {
      throw new Error("Failed to fetch daily scores.");
    }
    const data = await response.json();
    return data;
  } catch (error) {
    console.error("Error fetching daily scores:", error);
    return null;
  }
};

let events = [];
let spikes = [];
let lastCorrectionBolusIndex = -6;
let lastEarlyBolusIndex = -6;
let newExpectedBolusBars = []; // Temporary array to hold bars before setting state

const [earlyBolusIndexes, setEarlyBolusIndexes] = useState({});
const [supplementalBolusIndexes, setSupplementalBolusIndexes] = useState({});
const [correctionBolusIndexes, setCorrectionBolusIndexes] = useState({});
const [expectedBolusIndexes, setExpectedBolusIndexes] = useState({});
const [doubleBolusIndexes, setDoubleBolusIndexes] = useState({});
const [eventMessages, setEventMessages] = useState([]);
const [expectedBolusBars, setExpectedBolusBars] = useState([]);

let spikeStart = null;
let lastNoBolusIndex = -6;
let spikeEnd = null;
let annotations = [];
let spikeTimes = [];

useEffect(() => {
  setEarlyBolusIndexes(prevIndexes => ({ ...prevIndexes }));
  setCorrectionBolusIndexes(prevIndexes => ({ ...prevIndexes }));
  setDoubleBolusIndexes(prevIndexes => ({ ...prevIndexes }));
  setExpectedBolusBars([...newExpectedBolusBars]);
}, []);  // ‚úÖ FIX: Empty dependency array to run only once on mount

let numIntervalsForSpikeA = 4; // 120 minutes (assuming 15-minute intervals)
let spikeIncreaseThresholdA = 65;

let numIntervalsForSpikeB = 2;  // 60 minutes (assuming 15-minute intervals)
let spikeIncreaseThresholdB = 65;

  const checkForBGSpike = (data, i) => {  // ‚úÖ Main Function: Check If a Spike Occurs
  let newBgValueXminAhead = getBgValueAtInterval(data, i, numIntervalsForSpikeA); // ‚úÖ Get BG value X min ahead
  let newBgValueYminAhead = getBgValueAtInterval(data, i, numIntervalsForSpikeB); // ‚úÖ Get BG value Y min ahead
  let bgIncreaseOverXmin = calcucorrectionBgIncrease(data[i], newBgValueXminAhead); // ‚úÖ Compute BG increase over X min
  let bgIncreaseOverYmin = calcucorrectionBgIncrease(data[i], newBgValueYminAhead); // ‚úÖ Compute BG increase over Y min

  // ‚úÖ Returns TRUE if BG increases meet the threshold & new values are high
  if (
    bgIncreaseOverXmin >= spikeIncreaseThresholdA 
   //&& bgIncreaseOverYmin >= spikeIncreaseThresholdB
    ) 
    {
      return true;
        if (newBgValueXminAhead > 205 
          || newBgValueYminAhead > 220
        ){
          return true;
        }
    }  
  return false;
};

 // ‚úÖ Helper Function: Get BG Value at a Specific Interval
 const getBgValueAtInterval = (data, i, numIntervals) => {
  return data[i + numIntervals] !== null ? data[i + numIntervals] : null;
  };

  // ‚úÖ Helper Function: Calcucorrection BG Increase Over Time
  const calcucorrectionBgIncrease = (initialValue, newValue) => {
  return newValue !== null ? newValue - initialValue : 0;
  };


  let spikeDetected = false;

const detectBgSpikes = (data) => {
    clearEvents(); // Clear previous events before detecting new ones
    
    let lastSpikeIndex = -6;
    let inSpike = false;
    let spikeAnnotations = [];
    let troughStart = 0;
    let peakEnd = 0;

    for (let i = 0; i < data.length; i++) {
        if (data[i] !== null) {
          spikeDetected = checkForBGSpike(data, i);

            if (spikeDetected && (i - lastSpikeIndex >= 6)) {
              let { formatted, militaryTime } = formatTime(i);
              
              //eventMessages.time.sort((a, b) => a.time - b.time);
              lastSpikeIndex = i;
              troughStart = findTroughStart(data, i);
              peakEnd = findPeakEnd(data, i);

              if (spikeTimes.indexOf(troughStart) < 0){
                spikeAnnotations.push({ xMin: troughStart, xMax: peakEnd });
                let spikePeakBG = getBgValueAtInterval(data,peakEnd,2);
                let spikeRange = spikePeakBG - getBgValueAtInterval(data,troughStart,0);
                spikeTimes.push([troughStart,spikePeakBG]); // Store spike start time

                addEvent(
                  militaryTime, 
                  `${formatted} - Carb Increase (spike) detected`, 
                  'classYellowBold',
                  
                );
              }

              majorEventsList[i] = [
                "Carb Increase (spike) detected",
                (" üïí " +  formatted),
                'This is normal after a meal or snack.',
                'classYellowBold'
              ];

              

              if (!inSpike) {
                  spikeStart = troughStart;
                  inSpike = true;
              }
            }

            if (inSpike && (!spikeDetected || i === data.length - 10)) {
                spikeEnd = i;
                annotations.push({
                    type: "box",
                    xMin: troughStart,
                    xMax: peakEnd+1,
                    backgroundColor: "rgba(255, 255, 0, 0.2)",
                    borderWidth: 0,
                    drawTime: "beforeDatasetsDraw",
              });
              
              inSpike = false;
         }
      }
    }
    setSpikeAnnotations(annotations);
    
  };

  /**
  * **Helper Functions**
  */

// ‚úÖ Finds lowest point before a spike (Trough)
const findTroughStart = (data, i) => {
  let troughStart = i;
  while (troughStart > 0) {
    
    if (
      (data[troughStart - 1] - data[troughStart] <= -1) 
      && (data[troughStart - 4] <= data[troughStart])
      
    ){
      troughStart--;
    }
    else{
      break;
    }
      
  }
  return troughStart;
};

// ‚úÖ Finds highest point after a spike (Peak)
const findPeakEnd = (data, i) => {
  let peakEnd = i;
  while (peakEnd < data.length) {
    if (
      (data[peakEnd + 2] >= (data[peakEnd])) 
      && (data[peakEnd + 4] >= (data[peakEnd]))
      || (data[peakEnd + 7] >= (data[peakEnd]))
      ) {   // || ((data[peakEnd + 3] >= (data[peakEnd])))
      peakEnd++;
      
    } 
    else{ 
      break;
    }
  }
  //spikeDetected = false
  return peakEnd;
};






const detectCorrectionBolus = (data, bolusData, spikeTimes) => {
  let newCorrectionBolusIndexes = { ...correctionBolusIndexes }; // Copy existing correction bolus indexes

  for (let i = 0; i < bolusData.length; i++) {
      
      // ‚úÖ Ensure at least 10 minutes since last detected bolus
      if (bolusData[i] !==null){
        if (bolusData[i]["Initial Delivery"] != 'DETECTED') { // && (i - lastCorrectionBolusIndex >= 10)
          
          // ‚úÖ Check if bolus falls within 195 min after a spike
            let spikeStart = spikeTimes.find(spike => i - spike[0] > 0 && i - spike[0] <= 10); 
  
            if (spikeStart !== undefined) { // ‚úÖ If valid spike found
                let { formatted: correctionBolusFormatted, militaryTime: correctionBolusMilitary } = formatTime(i);
                let _correctionBolusMessage = "Heads up! Administering your bolus correction after the ideal time can lead to higher post-meal blood sugar ";
                _correctionBolusMessage += "levels. Aim for a more timely dose with accurately estimated carbs in order to improve control.\n(‚Äì15 points!)";
                
                if (spikeStart[1]>150)
                  _correctionBolusMessage+="\n„Ö§\n ‚ö†Ô∏è Analysis:\nBG increased close to " + spikeStart[1] + ", even after the bolus. It sounds like you might have under-estimated the amount of carbs for this meal. "
                
                
                // ‚úÖ Store this bolus in the state to prevent duplicates
                newCorrectionBolusIndexes[i] = correctionBolusFormatted;
                lastCorrectionBolusIndex = i; // ‚úÖ Update last bolus index
                bolusData[i]["Initial Delivery"] = 'DETECTED';
                majorEventsList[i] = [
                  "Correction Bolus Detected",
                  (" üïí " +  correctionBolusFormatted),
                  _correctionBolusMessage,
                  'classRedBold'
                ];
  
            }
        }
      }
      
  }
  setCorrectionBolusIndexes(newCorrectionBolusIndexes); // ‚úÖ Update state with detected correction boluses
};

const detectEarlyBolus = (data, bolusData, spikeTimes) => {
  let updatedIndexes = { ...earlyBolusIndexes }; // Copy existing early bolus indexes

  for (let i = 0; i < bolusData.length; i++) {
    if (bolusData[i] !==null){
      if ((bolusData[i]["Initial Delivery"] != 'DETECTED') && (i - lastEarlyBolusIndex >= 8)) { // ‚úÖ Ensure at least 8 minutes since last early bolus
        let spikeStart = spikeTimes.find(spike => (spike[0] - i >= 0 && spike[0] - i <= 7)); // ‚úÖ Check if bolus was 5-25 min before spike

        if (spikeStart !== undefined) { // ‚úÖ If valid early bolus found
            let { formatted: earlyBolusFormatted, militaryTime: earlyBolusMilitary } = formatTime(i);
            let _earlyBolusMessage = "Nice work! Being aware of upcoming meal intake and proactively providing a ";
            _earlyBolusMessage+="proportional bolus helps to keep the spikes down to a minimum.\n(+20 points!)";

            if (spikeStart[1]>150)
              _earlyBolusMessage+="\n„Ö§\n üü¢ Analysis:\nBG increased close to " + spikeStart[1] + ", even after the bolus. It sounds like you might have under-estimated the amount of carbs for this meal. "
            
            // ‚úÖ Store this bolus in the state to prevent duplicates
            updatedIndexes[i] = ["üü¢ Early Bolus Detected",earlyBolusFormatted];
            lastEarlyBolusIndex = i; // ‚úÖ Update last early bolus index
            bolusData[i]["Initial Delivery"] = 'DETECTED';

            majorEventsList[i] = [
              "Meal Bolus Detected", 
              (" üïí " + earlyBolusFormatted),
              _earlyBolusMessage,
              'classGreenBold'
            ];

                      
        }
      }
    }  
    
  }
  setEarlyBolusIndexes(updatedIndexes); // ‚úÖ Update state with detected early boluses
};

const detectExpectedBolus = (data, bolusData) => {
  let highBgStart = null;
  

  for (let i = 0; i < data.length; i++) {
      if (data[i] !== null && data[i] > 200) { 
          if (highBgStart === null) {
              highBgStart = i; 
          }

          if (i - highBgStart >= 6) {  
              let noBolusDetected = !bolusData.slice(highBgStart, i).some(bolus => bolus !== null);

              if (noBolusDetected) { 
                  let expectedBolusStart = highBgStart;
                  let expectedBolusEnd = i;

                  while (
                      expectedBolusEnd < data.length &&
                      data[expectedBolusEnd] !== null &&
                      data[expectedBolusEnd] > 200 
                      //&& bolusData[expectedBolusEnd] === null
                  ) {
                      expectedBolusEnd++;
                  }

                  let expectedBolusCenter = Math.floor((expectedBolusStart + expectedBolusEnd) / 2);

                  let { formatted: expectedBolusFormatted, militaryTime: expectedBolusMilitary } = formatTime(expectedBolusCenter);
                  let _expectedBolusMessage = "Attention! Missing your scheduled bolus might cause your blood sugar to spike, or cause you to remain at elevated glucose levels. "
                  _expectedBolusMessage += "Remember to dose on time for better overall management.\n(‚Äì25 points!)";

                  addEvent(
                    expectedBolusMilitary,
                    `${expectedBolusFormatted} - Expected bolus (BG > 200 for 120 min).`,
                    'classOrangeBold',
                    _expectedBolusMessage
                  );

                  majorEventsList[i] = [
                    "Expected Bolus Detected", 
                    (" üïí " + expectedBolusFormatted),
                    _expectedBolusMessage,
                    'classOrangeBold'
                  ];

                  // ‚úÖ Store expected bolus bar data
                  newExpectedBolusBars.push({
                      index: expectedBolusCenter,
                      value: 0.5, // Adjust height as needed
                      backgroundColor: "rgba(255, 165, 0, 0.8)",
                  });
              }
              highBgStart = null;
          }
      } else {
          highBgStart = null;
      }
  }

  // ‚úÖ Update state with detected bars
  setExpectedBolusBars(newExpectedBolusBars);
};

const detectSupplementalBolus = (bolusData) => {
  let newSupplementalBolusIndexes = { ...supplementalBolusIndexes }; // Copy existing

  for (let i = 0; i < bolusData.length; i++) {
      if (bolusData[i] !== null) {
          // ‚úÖ If bolus is NOT classified as Early, Correction, or Expected
          if (
              !earlyBolusIndexes.hasOwnProperty(i) &&
              !correctionBolusIndexes.hasOwnProperty(i) &&
              !expectedBolusIndexes.hasOwnProperty(i)
          ) {
              let { formatted: supplementalBolusFormatted, militaryTime: supplementalBolusMilitary } = formatTime(i);
              let _supplementalBolusMessage = "Great job staying on top of things! \nA timely correction bolus helps bring your blood sugar ";
              _supplementalBolusMessage += "back into the target range. Keep monitoring your levels for continued success.\n(+10 points!)";

              // ‚úÖ Store in event list and highlight in UI
              addEvent(supplementalBolusFormatted, `${supplementalBolusFormatted} - Supplemental Bolus detected.`,'classGreenBold',_supplementalBolusMessage);
              newSupplementalBolusIndexes[i] = supplementalBolusFormatted;
          }
      }
  }
  setSupplementalBolusIndexes(newSupplementalBolusIndexes);
};

const addEvent = (time, description, className, details) => {
  setEventMessages(prevEvents => {
      // Prevent duplicate events
      if (!prevEvents.some(event => event.time === time && event.description === description)) {
          return [...prevEvents, { time, description, className, details }];
      }
      return prevEvents; // Return existing events if duplicate is found
  });
};

const removeEvent = (time) => {
  setEventMessages(prevEvents => prevEvents.filter(event => event.time !== time));
};

const clearEvents = () => {
  setEventMessages([]);
};

const formatTime = (index) => {
  let hours = Math.floor(index / 4);
  let minutes = (index % 4) * 15;
  let period = hours >= 12 ? "p.m." : "a.m.";
  let adjustedHours = hours % 12 || 12; // Convert 0 to 12-hour format
  let totalMinutes = (hours % 24) * 60 + minutes; // Military time for sorting

  return {
      formatted: `${adjustedHours}:${minutes.toString().padStart(2, "0")} ${period}`,
      militaryTime: totalMinutes
  };
};

// üìä Add Chart Annotations (Yellow for Spike, Orange for No Bolus)
const addChartAnnotations = (start, end, bolusData) => {
  let annotations = [];

  // Add Yellow Region (BG Spike)
  annotations.push({
      type: "box",
      xMin: start, // Start slightly after spike detection
      xMax: end,
      backgroundColor: "rgba(255, 255, 0, 0.2)", // Yellow for BG spike
      borderWidth: 0,
      drawTime: "beforeDatasetsDraw",
  });

  // Add Orange Region (No Bolus Detected)
  let noBolus = !bolusData.slice(start, end).some(bolus => bolus !== null);
  if (noBolus) {
      annotations.push({
          type: "box",
          xMin: end,
          xMax: Math.min(end + 2, bolusData.length - 1), // 30 minutes
          backgroundColor: "rgba(255, 165, 0, 0.3)", // Orange for no bolus
          borderWidth: 0,
          drawTime: "beforeDatasetsDraw",
      });
  }

  return annotations;
};

const updateDate = (days) => {
  const newDate = new Date(selectedDate);
  newDate.setDate(newDate.getDate() + days);
  setSelectedDate(newDate.toISOString().split("T")[0]);

  // ‚úÖ Clear existing events before fetching new data
  clearEvents(); 
  setMajorEvents([]); 

  // Reset the accordion
  setExpandedIndex(null);

  // ‚úÖ Fetch new data and detect events
  //fetchData(newDate.toISOString().split("T")[0]);

};


const getBgPointColor = (context) => {
  const index = context.dataIndex;
  
  // ‚úÖ Check if the index falls within any spike range
  for (let spike of spikeAnnotations) {
      if (index >= spike.xMin && index <= spike.xMax) {
          return "rgb(255, 227, 227)"; // üî¥ Red for BG points within spike range
      }
  }
  //"rgb(203, 245, 245)"
  return "rgb(75, 192, 192)"; // Default color for BG points
};



const chartData = {
    labels: Array.from({ length: 96 }, (_, i) =>
      `${Math.floor(i / 4)}:${((i % 4) * 15).toString().padStart(2, "0")}`
    ),
    datasets: [
      {
        label: "CGM Glucose Levels",
        data: cgmData,
        borderColor: "rgb(75, 192, 192)",
        backgroundColor: "rgba(187, 255, 255, 0.2)",
        pointRadius: 4,
        pointBackgroundColor: (context) => getBgPointColor(context), // ‚úÖ Apply dynamic color function
            fill: true,
      },
      {
        label: "Bolus Insulin Delivered",
        data: bolusData,
        type: "bar",
        backgroundColor: (context) => getBolusBarColor(context),
        borderColor:  (context) => getBolusBarColor(context),
        borderWidth: 1,
        barPercentage: 4.1,
        categoryPercentage: 1.0,
        yAxisID: "y2",
    },
    {
      label: "Expected Bolus",
      data: new Array(96).fill(null).map((_, i) =>
          expectedBolusBars.some(bar => bar.index === i) ? 0.5 : null
      ), 
      type: "bar",
      backgroundColor: "rgba(255, 165, 0, 0.8)", // Orange for expected bolus
      borderWidth: 0,
      yAxisID: "y2",
      barPercentage: 5, 
      categoryPercentage: 1.2,
  },
    ],
};

const updateTooltipForBolus = (tooltipItem) => {
    const index = tooltipItem.dataIndex;
    const dataset = tooltipItem.dataset.label;
    if (dataset === "Bolus Insulin Delivered") {
        let tooltipMessages = [];
        
        if (doubleBolusIndexes.hasOwnProperty(index)) {
            tooltipMessages.push(`Additional Bolus Detected at ${doubleBolusIndexes[index]}`);
        } else if (correctionBolusIndexes.hasOwnProperty(index)) {
          tooltipMessages.push(`${majorEventsList[index][2]}`);
        } else if (earlyBolusIndexes.hasOwnProperty(index)) {
            tooltipMessages.push(`${majorEventsList[index][2]}`);
        }
        else if (supplementalBolusIndexes.hasOwnProperty(index)) {
          tooltipMessages.push(`Supplemental Bolus Detected at ${supplementalBolusIndexes[index]}`);
      }
        
        return tooltipMessages.length > 0 ? tooltipMessages.join("\n") : tooltipItem.formattedValue;

    }

      // ‚úÖ Add tooltip for "Expected Bolus"
    if (dataset === "Expected Bolus") {
          return "Bolus Expected: No bolus was detected in the expected range. (BG > 200 for 120 min)";
    }

    return tooltipItem.formattedValue;

};

const getBolusBarColor = (context) => {
  const index = context.dataIndex;
  if (doubleBolusIndexes.hasOwnProperty(index)) {
      return "rgba(255, 215, 0, 0.8)"; // üü° Yellow for Additional Bolus
  }
  if (correctionBolusIndexes.hasOwnProperty(index)) {
      return "rgba(255, 0, 0, 0.8)"; // üî¥ Red for Correction Bolus
  }
  if (earlyBolusIndexes.hasOwnProperty(index) || supplementalBolusIndexes.hasOwnProperty(index)) {
      return "rgba(75, 192, 75, 0.8)"; // üü¢ Green for Early & Supplemental Bolus
  }
  return "rgba(99, 239, 255, 0.8)"; // Default color
};

  const chartOptions = {
    responsive: true,
    maintainAspectRatio: false,
  
    scales: {
        y: { min: 0, max: 420 },
        y2: { min: 0, max: 10, position: "right", grid: { drawOnChartArea: false } },
        x: { ticks: { autoSkip: true, maxTicksLimit: 12 } },
    },
    plugins: {
        tooltip: {
            callbacks: {
                title: (tooltipItems) => {
                  let _thisIndex = tooltipItems[0].dataIndex;
                  if (majorEventsList[_thisIndex]!=null) {
                    return `${majorEventsList[_thisIndex][1]} - ${majorEventsList[_thisIndex][0]}`; // Change the title
                  }

                  return tooltipItems[0].label;
                },
                label: (tooltipItem) => {
                    let label = updateTooltipForBolus(tooltipItem);
                    return label.match(/(.{1,60})(\s|$)/g, "$1\n"); // Wrap text every 30 characters
                    //return label.match(/.{1,60}/g);
                }
            },
            displayColors: false, // Hide color boxes to save space
            bodyFont: { size: 12 }, // Adjust font size for better wrapping
            enabled: true,
            usePointStyle: true,
            bodyFont: { size: 16, weight: "normal" },  // Adjust font style
            titleFont: { size: 18, weight: "bold" }, 
            useHTML: true,
        },
        
        annotation: {
            annotations: [{
                type: "box",
                yMin: 80,
                yMax: 150,
                backgroundColor: "rgba(144, 238, 144, 0.2)", // Light green
                borderWidth: 0,
                drawTime: "beforeDatasetsDraw",
            },
            ...spikeAnnotations],
        },
        
    }
};


  const DailyScreen = () => {  };
  const [expandedIndex, setExpandedIndex] = useState(null);
  const toggleAccordion = (index) => {
    setExpandedIndex(expandedIndex === index ? null : index);
  };
  const eventDescription = `Correction bolus detected!\nAdditional information here.`;
  const htmlDescription = eventDescription.replace(/\n/g, '<br />');
  return (
    <div className="dailyChartHead" align="center">
      <Card>
        <CardContent>
          <Scoreboard dailyScore={dailyScore} />
          <table border={0} cellPadding={1}>
          <tbody>
            <tr>
              <td className="btnDateSelect"><Button className="btnDateSelect" onClick={() => updateDate(-1)}>‚Üê Back</Button></td>
              <td className="btnDateSelect">&nbsp;</td>
              <td><input
              type="date"
              value={selectedDate}
              onChange={(e) => setSelectedDate(e.target.value)}
              className="dateSelect"
            /></td>
              <td className="btnDateSelect">&nbsp;</td>
              <td><Button className="btnDateSelect" onClick={() => updateDate(1)}>Next ‚Üí</Button></td>
            </tr>
            </tbody>
          </table>
          <h3 className="text-xl font-semibold">Daily Blood Glucose Data</h3>
          <div style={{ height: "400px", width: "99%" }}>
            <Line data={chartData} options={chartOptions} />
          </div>
          
          

          {majorEventsList.length > 0 ? (
            <table border={0} height={1} cellPadding={0} cellSpacing={0} className="results_table">
              <tbody>

                
                {majorEventsList
                    .slice()
                    .sort((a, b) => a.time - b.time) // Ensure chronological order
                    .map((msg, index) =>  (
                      
                    <React.Fragment key={index}>
                      <tr>
                      <td 
                          style={{
                            verticalAlign:"top",
                            padding:1,
                            width:1
                            
                          }}
                          className= {msg[3] + `-image-container` }>
                          <a
                                onClick={() => toggleAccordion(index)}
                                style={{
                                  cursor: "pointer",
                                  verticalAlign:"top",
                                }}
                              >
                                <img src="../images/spacer.gif" height={40} className="imagebutton1" />

                              </a>
                        </td>
                        <td style={{
                              verticalAlign:"top",
                              padding:5
                              
                            }}>
                          
                         <a onClick={() => toggleAccordion(index)} style={{ cursor: "pointer",  }}
                          ><div>{msg[1]} - {msg[0]}</div>
                                                        
                            {expandedIndex === index && (
                            
                            <div className="events_table accordion-content " dangerouslySetInnerHTML={{ __html: msg[2].replace(/\n/g, '<br />') }}
                          >
                               </div>
                             
                           )}
                          </a>
                          
                        </td>
                      </tr>
                      <tr>
                        <td colSpan={2}>
                          
                        </td>
                      </tr>
                    </React.Fragment>
                  ))}
              </tbody>
            </table>
          ) : (
            <p>No significant events detected today.</p>
          )}

        </CardContent>
      </Card>
    </div>
  );
};

export default DailyScreen;
